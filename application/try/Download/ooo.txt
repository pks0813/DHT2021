
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes首页 新随笔 管理随笔 - 33  文章 - 0  评论 - 1  阅读 - 33416
go 文件读写
go 文件读写有很多方式

ioutil读文件

复制代码
package main

import (
    "io/ioutil"
    "fmt"
)

func main() {
    data,err := ioutil.ReadFile("a.txt")  #这里返回的data是一个字节切片
    if err!=nil{
        fmt.Println("File reading error", err)
    }
    fmt.Println(string(data))
}
复制代码
ioutil写文件

复制代码
package main

import (
    "io/ioutil"
)

func main() {
    content := "hello world!"
    ioutil.WriteFile("a.txt",[]byte(content),0777)  //如果文件a.txt已经存在那么会忽略权限参数，清空文件内容。文件不存在会创建文件赋予权限
}
复制代码
使用os包打开文件

复制代码
//open函数 func Open(name string) (file *File, err error)
Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.Open("a.txt")
    defer f.Close()
    data := make([]byte, 100)
    count,_ :=f.Read(data)
    fmt.Print(string(data[:count]))
}
//openfile函数
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式FileMode（如0666,即可读写，但是不可执行）
打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
参数flag可以结合使用：
os.O_WRONLY | os.O_CREATE | O_EXCL     //如果已经存在，则失败
os.O_WRONLY | os.O_CREATE              //如果已经存在，会覆盖写，不会清空原来的文件，而是从头直接覆盖写
os.O_WRONLY | os.O_CREATE | os.O_APPEND //如果已经存在，则在尾部添加写
参数perm：
linux中的权限rwx分别对应4 2 1，相加的值为7。如0666,即可读写，但是不可执行
package main

import (
    _"io/ioutil"
    "os"
    "fmt"
)
func main() {
    f,_ := os.OpenFile("a.txt",os.O_RDWR |os.O_APPEND,0777)//读写模式打开，写入追加
    defer f.Close()
    add_data :="this is add"
    num,_:=f.Write([]byte(add_data))
    fmt.Println(num)

    data := make([]byte, 100)
    count,err :=f.Read(data)
    if err!=nil{
        fmt.Println(err)  #这里会返回EOF错误，因为写入完毕后文件指针在最末尾，所以读取的时候是读不到内容的，需要重新打开一下这个文件
    }
    fmt.Print(string(data[:count]))
}
复制代码
 

将文件绑定在二进制文件中

packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。

复制代码
package main

import (
    "fmt"

    "github.com/gobuffalo/packr"
)

func main() {
    box := packr.NewBox("../a.txt")
    data := box.String("test.txt")
    fmt.Println("Contents of file:", data)
}
复制代码
逐行读取文件

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open(“a.txt”)   //因为bufio需要的是一个*os.File类型，所以我们换个方式读取，稍后再介绍一下
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
        log.Fatal(err)
    }
    }()
    s := bufio.NewScanner(f)
    for s.Scan() {
        fmt.Println(s.Text())
    }
    err = s.Err()
    if err != nil {
        log.Fatal(err)
    }
}
复制代码
分块读取文件

当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio包来完成。

复制代码
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
)

func main() {
    //fptr := flag.String("fpath", "test.txt", "file path to read from")
    //flag.Parse()

    f, err := os.Open("a.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err = f.Close(); err != nil {
            log.Fatal(err)
        }
    }()
    r := bufio.NewReader(f)
    b := make([]byte, 3)
    for {
        _, err := r.Read(b)
        if err != nil {
            fmt.Println("Error reading file:", err)
            break
        }
        fmt.Println(string(b))
    }
}
复制代码
 

分类: go 语言
好文要顶 关注我 收藏该文    
君子不徒语
关注 - 1
粉丝 - 1
+加关注
0 0
« 上一篇： go 发送http请求 
» 下一篇： go 学习之io/ioutil包
posted @ 2019-09-04 17:41  君子不徒语  阅读(5695)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云特惠：新用户首购云服务器低至0.7折，个人企业同享
【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
【推荐】阿里云云大使特惠：新用户购ECS服务器1核2G最低价87元/年
【推荐】投资训练营：一杯咖啡的价格，教你学会投资，增加被动收入
【推荐】加州大学伯克利分校高管教育：大数据与数学科学-在线课程
【推荐】和开发者在一起：华为开发者社区，入驻博客园科技品牌专区

编辑推荐： 
· 传统.NET 4.x应用容器化体验（4） 
· CSS 世界中的方位与顺序 
· 在 .NET 中创建对象的几种方式的对比 
· 10倍程序员的思考模型 
· 学习 CLR 源码：连续内存块数据操作的性能优化 
大数据与数据科学实战课程-468x60-3
最新新闻： 
· 只闻一声惊雷：教育市场化这就结束了？ 
· “硬骨头”余承东，会成为接班任正非的不二人选吗？ 
· 从李宁到鸿星尔克：不浪费每一场危机 
· iPad mini 将为谁「复活」？ 
· 国产Android厂商大力宣传的「内存融合」，到底是不是智商税？ 
» 更多新闻...
公告
昵称： 君子不徒语 
园龄： 2年 
粉丝： 1 
关注： 1
+加关注
搜索

 

 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
随笔分类
go 语言(18)
python(7)
redis(7)
随笔档案
2019年9月(12)
2019年8月(16)
2019年7月(5)
最新评论
1. Re:python操作hbase
请问博主： Hbase_thrift.IOError: IOError(message=b'org.apache.hadoop.hbase.NamespaceNotFoundException: 这个...
--李华梅
阅读排行榜
1. go 发送http请求(10452)
2. go 文件读写(5693)
3. python 发送kafka(3583)
4. go 学习之bufio(2259)
5. go select(1558)
评论排行榜
1. python操作hbase(1)
推荐排行榜
1. go 发送http请求(1)
2. go module管理依赖包(1)
3. python 数据压缩(1)
4. JsonSchema 启蒙(1)
Copyright © 2021 君子不徒语 
Powered by .NET 5.0 on Kubernetes